/***
 * Java Doc: https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html
 * Link to GeeksforGeeks : https://www.geeksforgeeks.org/stream-in-java/
 * Link to baeldung : https://www.baeldung.com/java-8-streams
 * Link to javapapers : https://javapapers.com/java/java-stream-api/
 *
 * List of Methods in Stream
 *
 * Method and Description
 * allMatch(Predicate<? super T> predicate)
 * Returns whether all elements of this stream match the provided predicate.
 *
 * anyMatch(Predicate<? super T> predicate)
 * Returns whether any elements of this stream match the provided predicate.
 *
 * builder()
 * Returns a builder for a Stream.
 *
 * collect(Collector<? super T,A,R> collector)
 * Performs a mutable reduction operation on the elements of this stream using a Collector.
 *
 * collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)
 * Performs a mutable reduction operation on the elements of this stream.
 *
 * concat(Stream<? extends T> a, Stream<? extends T> b)
 * Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.
 *
 * count()
 * Returns the count of elements in this stream.
 *
 * distinct()
 * Returns a stream consisting of the distinct elements (according to Object.equals(Object)) of this stream.
 *
 * empty()
 * Returns an empty sequential Stream.
 *
 * filter(Predicate<? super T> predicate)
 * Returns a stream consisting of the elements of this stream that match the given predicate.
 *
 * findAny()
 * Returns an Optional describing some element of the stream, or an empty Optional if the stream is empty.
 *
 * findFirst()
 * Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty.
 *
 * flatMap(Function<? super T,? extends Stream<? extends R>> mapper)
 * Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.
 *
 * flatMapToDouble(Function<? super T,? extends DoubleStream> mapper)
 * Returns an DoubleStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.
 *
 * flatMapToInt(Function<? super T,? extends IntStream> mapper)
 * Returns an IntStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.
 *
 * flatMapToLong(Function<? super T,? extends LongStream> mapper)
 * Returns an LongStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.
 *
 * forEach(Consumer<? super T> action)
 * Performs an action for each element of this stream.
 *
 * forEachOrdered(Consumer<? super T> action)
 * Performs an action for each element of this stream, in the encounter order of the stream if the stream has a defined encounter order.
 *
 * generate(Supplier<T> s)
 * Returns an infinite sequential unordered stream where each element is generated by the provided Supplier.
 *
 * iterate(T seed, UnaryOperator<T> f)
 * Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.
 *
 * limit(long maxSize)
 * Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.
 *
 * map(Function<? super T,? extends R> mapper)
 * Returns a stream consisting of the results of applying the given function to the elements of this stream.
 *
 * mapToDouble(ToDoubleFunction<? super T> mapper)
 * Returns a DoubleStream consisting of the results of applying the given function to the elements of this stream.
 *
 * mapToInt(ToIntFunction<? super T> mapper)
 * Returns an IntStream consisting of the results of applying the given function to the elements of this stream.
 *
 * mapToLong(ToLongFunction<? super T> mapper)
 * Returns a LongStream consisting of the results of applying the given function to the elements of this stream.
 *
 * max(Comparator<? super T> comparator)
 * Returns the maximum element of this stream according to the provided Comparator.
 *
 * min(Comparator<? super T> comparator)
 * Returns the minimum element of this stream according to the provided Comparator.
 *
 * noneMatch(Predicate<? super T> predicate)
 * Returns whether no elements of this stream match the provided predicate.
 *
 * of(T... values)
 * Returns a sequential ordered stream whose elements are the specified values.
 *
 * of(T t)
 * Returns a sequential Stream containing a single element.
 *
 * peek(Consumer<? super T> action)
 * Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.
 *
 * reduce(BinaryOperator<T> accumulator)
 * Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any.
 *
 * reduce(T identity, BinaryOperator<T> accumulator)
 * Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.
 *
 * reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)
 * Performs a reduction on the elements of this stream, using the provided identity, accumulation and combining functions.
 *
 * skip(long n)
 * Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream.
 *
 * sorted()
 * Returns a stream consisting of the elements of this stream, sorted according to natural order.
 *
 * sorted(Comparator<? super T> comparator)
 * Returns a stream consisting of the elements of this stream, sorted according to the provided Comparator.
 *
 * toArray()
 * Returns an array containing the elements of this stream.
 *
 * toArray(IntFunction<A[]> generator)
 * Returns an array containing the elements of this stream, using the provided generator function to allocate the returned array,
 * as well as any additional arrays that might be required for a partitioned execution or for resizing.
 *
 * ****************************************************************************************************************************************************************************************
 *
 * Stateless Intermediate Operations
 * For example,
 *
 * map()
 * filter()
 * unsorted()
 * peek()
 * are stateless intermediate operations. Every individual element can be processed without the need for sharing information between them for processing.
 *
 * Stateful Intermediate Operations
 * For example,
 *
 * sorted()
 * distinct()
 * limit()
 * etc are known as stateful operations. Because elements cannot be processed individually, they need to be compared with one another thus requiring information to be retained.
 *
 * Terminal Operations
 * Terminal operations consumes the stream pipeline. It does not produce another stream like intermediate operations. It produces a result or a side-effect.
 *
 * Following are some of the available terminal operations in the API,
 *
 * sum()
 * min()
 * max()
 * count()
 * average()
 * collect()
 * reduce()
 * Once the terminal operation completes execution, then the stream is completed and it cannot be used further. If there is a need to use similar stream,
 * then a new stream should be created. This is similar to the concept of iteration using Iterable interface.
 *
 *
 **/

package com.sourav.java8.stream;

import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.LongStream;
import java.util.stream.Stream;

public class TestStreamAPI {
    public static void main(String[] args) {

        List<Person> persons =
                Arrays.asList(
                        new Person("Max", 18),
                        new Person("Peter", 23),
                        new Person("Pamela", 23),
                        new Person("David", 12));

        Arrays.asList("a1", "a2", "b2", "b3", "c1")
                .stream()
                .findFirst()
                .ifPresent(System.out::println);
        LongStream.range(2l, 3l).forEach(System.out::println);

        System.out.println("..........................................");

        Stream.of("d2", "a2", "b1", "b3", "c")  // Streams objects/elements moves along vertially in the chain..
                .filter(s -> {
                    System.out.println("filter: " + s);
                    return true;
                })
                .forEach(s -> System.out.println("forEach: " + s));

        System.out.println("..........................................");

        Stream.of("d2", "a2", "b1", "b3", "c")
                .map(s -> {
                    System.out.println("map: " + s);
                    return s.toUpperCase();
                })
                .anyMatch(s -> {  // If return true, it will not execute the rest of the elements in stream
                    System.out.println("anyMatch: " + s);
                    return s.startsWith("A");
                });

        System.out.println("..........................................");

        Stream.of("d2", "a2", "b1", "b3", "c")
                .map(s -> {
                    System.out.println("map: " + s);
                    return s.toUpperCase();
                })
                .filter(s -> {  // This returns true if condition matches and proceed downword. Otherwise move on to next stream elements.
                    System.out.println("filter: " + s);
                    return s.startsWith("A");
                })
                .forEach(s -> System.out.println("forEach: " + s));

        System.out.println("..........................................");

        /**
         * We can greatly reduce the actual number of executions if we change the order of the operations, moving filter to the beginning of the chain:
         **/
        Stream.of("d2", "a2", "b1", "b3", "c")
                .filter(s -> {
                    System.out.println("filter: " + s);
                    return s.startsWith("a");
                })
                .map(s -> {
                    System.out.println("map: " + s);
                    return s.toUpperCase();
                })
                .forEach(s -> System.out.println("forEach: " + s));

        System.out.println("..........................................");

        Stream.of("d2", "a2", "b1", "b3", "c")
                .sorted((s1,s2)->{
                        System.out.printf("sort: %s; %s\n", s1, s2);
                        return s1.compareTo(s2);
                }).forEach(s -> System.out.println("forEach: " + s));

        System.out.println("..........................................");

        // In case of sorting, unlike the other methods, the "sorted" method will be executed to all elements and then process downwords.
        // In other words sorted is executed horizontally.
        // It's a so called stateful operation since in order to sort a collection of elements you have to maintain state during ordering.
        Stream.of("d2", "a2", "b1", "b3", "c")
                .sorted((s1, s2) -> {
                    return s1.compareTo(s2);
                })
                .filter(s -> {
                    System.out.println("filter: " + s);
                    return s.startsWith("a");
                })
                .map(s -> {
                    System.out.println("map: " + s);
                    return s.toUpperCase();
                })
                .forEach(s -> System.out.println("forEach: " + s));

        System.out.println("..........................................");

        /**  Reusing Streams
         *
         * Java 8 streams cannot be reused. As soon as you call any terminal operation the stream is closed:
         *
         * Stream<String> stream =
         *     Stream.of("d2", "a2", "b1", "b3", "c")
         *         .filter(s -> s.startsWith("a"));
         *
         * stream.anyMatch(s -> true);    // ok
         * stream.noneMatch(s -> true);   // exception
         *
         * Calling noneMatch after anyMatch on the same stream results in the following exception:
         *
         * java.lang.IllegalStateException: stream has already been operated upon or closed
         *     at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)
         *     at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459)
         *     at com.winterbe.java8.Streams5.test7(Streams5.java:38)
         *     at com.winterbe.java8.Streams5.main(Streams5.java:28)
         *
         * To overcome this limitation we have to create a new stream chain for every terminal operation
         * we want to execute, e.g. we could create a stream supplier to construct a new stream with all
         * intermediate operations already set up:
         *
         * In the below code Each call to get() constructs a new stream on which we are save to call the desired terminal operation.
         *
         **/

        Supplier<Stream<String>> streamSupplier =
                () -> Stream.of("d2", "a2", "b1", "b3", "c")
                        .filter(s -> s.startsWith("a"));
        streamSupplier.get().anyMatch(s -> true);   // ok
        streamSupplier.get().noneMatch(s -> true);  // ok

        System.out.println("..........................................");
        System.out.println("...............USE OF COLLECTORS...............");

        List<Person> personList = persons.stream().filter(s-> s.name.startsWith("P")).collect(Collectors.toList());
        System.out.println("To List: "+personList);
        Set<Person> personSet = persons.stream().filter(s-> s.name.startsWith("P")).collect(Collectors.toSet());
        System.out.println("To Set: "+personSet);

        // Group by persons according to age..
        Map<Integer,List<Person>> personAgeMap=persons.stream().collect(Collectors.groupingBy(s->s.age));
        personAgeMap.forEach((age, p) -> System.out.format("age %s: %s\n", age, p));

        System.out.println("..........................................");

        IntSummaryStatistics ageSummary =
                persons
                        .stream()
                        .collect(Collectors.summarizingInt(p -> p.age));

        System.out.println("Pring age Summary: \n"+ ageSummary);

        System.out.println("..........................................");

        // Putting Person in a single line of string..
        String phrase = persons
                .stream()
                .filter(p -> p.age >= 18)
                .map(p -> p.name)
                .collect(Collectors.joining(" and ", "In Germany ", " are of legal age."));
        System.out.println(phrase);

        System.out.println("..........................................");

        Map<Integer, String> map = persons
                .stream()
                .collect(Collectors.toMap(
                        p -> p.age,
                        p -> p.name,
                        (name1, name2) -> name1 + ";" + name2));

        System.out.println(map);

        System.out.println("..........................................");
        System.out.println("...........OUR OWN COLLLECTOR.............");

        Collector<Person, StringJoiner, String> personNameCollector =
                Collector.of(
                        () -> new StringJoiner(" | "),          // supplier
                        (j, p) -> j.add(p.name.toUpperCase()),  // accumulator
                        (j1, j2) -> j1.merge(j2),               // combiner
                        StringJoiner::toString);                // finisher

        String names = persons
                .stream()
                .collect(personNameCollector);

        System.out.println("New collectors using StringJoiner: \n"+names);  // MAX | PETER | PAMELA | DAVID

        System.out.println("..........................................");

        System.out.println("..........FLATMAP EXAMPLES................");
       // See Flatmapdemp.java
    }

    static class Person {
        String name;
        int age;

        Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public String toString() {
            return name;
        }
    }
}
